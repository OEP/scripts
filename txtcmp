#!/usr/bin/env python

import sys
import re
import functools

g_Files = dict()

"""
  The following is Shao-Chuan Wang's implementation of the LCS problem
  modified for sequences of strings.

  Available at: http://bit.ly/THtO36
"""

def cached(func):
  cache = {}
  def template(*args): #: template is wrapper; func is wrapped
    strhash = ""
    for arg in args:
      tmp = ", ".join(arg)
      strhash += tmp
      strhash += "||"
    key = (func, strhash)
    try:
      ret = cache[key]
    except KeyError:
      ret = func(*args)
      cache[key] = ret
    else:
      pass
    return ret

  functools.update_wrapper(template, func)
  return template

@cached
def LCSLength(str1, str2):
  if len(str1)==0 or len(str2)==0:
    return 0
  if str1[-1] == str2[-1]:
    return LCSLength(str1[:-1], str2[:-1])+1
  else:
    return max(LCSLength(str1, str2[:-1]), LCSLength(str1[:-1], str2))

@cached
def LCS(str1, str2):
  if len(str1)==0 or len(str2)==0:
    return []
  if str1[-1] == str2[-1]:
    return LCS(str1[:-1], str2[:-1]) + [str1[-1]]
  else:
    candidate1 = LCS(str1[:-1], str2)
    candidate2 = LCS(str1, str2[:-1])
    if len(candidate1) >= len(candidate2):
      return candidate1
    else:
      return candidate2

""" END LCS IMPLEMENTATION """

def filter_lines(filename):
  global g_Files
  if filename in g_Files: return g_Files[filename]

  fp = open(filename)
  linebuffer = g_Files.setdefault(filename, list())
  for line in fp:
    line = line.strip()
    line = re.sub("[ \t]+", " ", line)
    if line != "":
      linebuffer.append(line)
  fp.close()
  return linebuffer


def score(a, b):
  return 1.0

def main():
  if len(sys.argv) != 3:
    print "Usage: %s <file1> <file2>" % sys.argv[0]
    sys.exit(1)
  
  files = sys.argv[1:]

  print LCSLength(filter_lines(files[0]), filter_lines(files[1]))

  for i in range( len(files) ):
    for j in range(i+1, len(files) ):
      pass

if __name__ == "__main__":
  main()
